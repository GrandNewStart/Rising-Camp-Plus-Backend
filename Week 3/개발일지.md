# 개발일지

## 핵심 개념 정리
 
### Java Spring Framework 시작

목표: 스프링 프레임워크의 핵심 기능 이해

과정:
1. Tighly Coupled 자바 코드 생성
2. Loosely Coupled 자바 코드 생성
3. Loose Coupling Sprint level 1
4. Loose Coupling Sprint level 2

#### 1. Tighly Coupled 자바 코드 생성

start.spring.io(spring initializr) 에 접속하여 간단하게 스프링 프로젝트를 생성할 수 있다.
- Project: Maven
- Language: Java 
- Spring Boot: 최신 정식 버전(SNAPSHOT이라고 표시된 건 현재 개발중인 버전이라는 뜻 
- Project Metadata: 알아서

프로젝트 생성을 누르고 프로젝트 파일을 다운받는다.
Eclipse나 intelliJ IDEA로 연다.
이제부터 코딩 시작.
다음과 같은 메인 앱 클래스를 생성한다.
    
    public class AppGamingBasicJava {

        public static void main(String[] args) {
            var marioGame = new MarioGame();
            var gameRunner = new GameRunner(marioGame);
            gameRunner.run();
        }

    }
그리고 여기에 필요한 클래스 파일들, MarioGame과 GameRunner는 다음과 같이 구현된다.

    public class MarioGame {

        public void up() {
            System.out.println("Jump");
        }

        public void down() {
            System.out.println("Go into a hole");
        }

        public void left() {
            System.out.println("Go back");
        }

        public void right() {
            System.out.println("Accelerate");
        }

    }
    

    
    public class GameRunner {

        MarioGame game;

        public GameRunner(MarioGame game) {
            this.game = game;
        }

        public void run() {
            System.out.println("Running game: " + game);
            game.up();
            game.down();
            game.left();
            game.right();
        }

    }
이제 AppGamingBasicJava를 실행하면 다음과 같은 출력이 이뤄질 것이다.

    Jump
    Go into a hole
    Go back
    Accelerate
    
이 코드는 'Tightly Coupled' 코드의 전형을 보여준다. 만약 MarioGame이 아닌, 새로운 게임, SonicGame을 실행하려고 할 때는 MarioGame이 구현한 모든 기능들을 복붙한 후 기능을 구현해야 할 것이다. 그리고 그렇게 구현된  SonicGame을 GameRunner 클래스에 변수로 추가하고, 이를 초기화하는 생성자를 추가하고, run() 함수 내에서 분기처리하여 up, down, left, right를 각각의 ...Game 객체에 대해 호출해줘야 하는 번거로움이 생긴다. 이를 구현하면 다음과 같을 것이다. 

    public class GameRunner {

        MarioGame marioGame;
        SonicGame sonicGame;

        public GameRunner(MarioGame game) {
            this.marioGame = game;
        }

        public GameRunner(SonicGame game) {
            this.sonicGame = game;
        }

        public void run() {
            if (marioGame != null) {
                System.out.println("Running game: " + marioGame);
                marioGame.up();
                marioGame.down();
                marioGame.left();
                marioGame.right();
                return;
            }
            if (sonicGame != null) {
                System.out.println("Running game: " + sonicGame);
                sonicGame.up();
                sonicGame.down();
                sonicGame.left();
                sonicGame.right();
            }
        }

    }

이는 GameRunner와 MarioGame의 관계가 'Tightly Coupled' 상태이기 때문이다. 둘 사이의 관계가 아주 끈적하기 때문에 여기에 새로운 관계를 추가하고자 할 때도, 더 많은 작업이 필요한 것이다. 인간관계와 똑같다. 너무 정 주면 떠나기 힘들어진다. 그럼 정을 덜 주는 코드로 이를 바꿔보자. 서로 딱 할것만 하고 헤어지는 'Loosely Coupled' 상태로 만들어보자는 것이다.

#### 2. Loosely Coupled 자바 코드 생성

각 게임 클래스들이 가진 공통된 동작을 인터페이스로 정의해야 한다. 다음과 같은 인터페이스를 생성한다.

    public interface GamingConsole {

        void up();
        void down();
        void right();
        void left();

    }

그리고 MarioGame과 SonicGame 모두 이 GamingConsole 인터페이스를 구현하게 한다. 다음과 같을 것이다.

    public class MarioGame implements GamingConsole {

        public void up() { 
            System.out.println("Jump"); 
        }

        public void down() {
            System.out.println("Go into a hole");
        }

        public void left() { 
            System.out.println("Go back"); 
        }

        public void right() { 
            System.out.println("Accelerate"); 
        }

    }


    
    public class SonicGame implements GamingConsole {

    public void up() {
        System.out.println("Jump");
    }

    public void down() {
        System.out.println("Crouch");
    }

    public void left() {
        System.out.println("Run back");
    }

    public void right() {
        System.out.println("Run");
    }

}
