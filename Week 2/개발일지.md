# 개발일지

## 과제 계획서

## 핵심 개념 정리

### 시작하기
    
    데이터베이스의 정의: 접근을 위한 인터페이스를 제공하는 전산화된 데이터 집합
    데이터베이스의 구성
        - 데이터의 집합
        - 데이터를 조작하거나 접근하기 위한 방법
    DBMS: 어플리케이션이 DB를 사용하기 위해 존재하는 중간 인터페이스
    보통 '데이터베이스'라고 하면 DB와 DBMS를 묶어서 정의한다.
    (DB+DBMS)의 종류: PostgreSQL, MySQL, Oracale DB, SQLite
    SQL: 데이터베이스와 '소통'하기 위한 언어
    SQL을 사용하는 관계형 DB: MySQL, SQLite, PostgreSQL, Oracle, ...
    다른 DB를 쓰더라도 SQL 문법은 '대부분' 공통이다. 조금씩 다른 부분들은 있다.
    MySQL 루트 실행 커맨드: mysql -u root -p
    
### 테이블 생성

    MySQL 데이터베이스 서버 안에 다수의 독립된 데이터베이스들이 존재한다.
    모든 데이터베이스를 조회하는 커맨드
        show databases; 
    새 데이터베이스 생성
        CREATE DATABASE <name>;
    데이터베이스 이름은 무엇이든 될 수 있지만 공백은 가급적 피하는 것이 좋다.
    SQL 키워드는 보통 대문자로 쓰는데 사실 필수는 아니다. 하지만 가독성 면에서 좋다.
    데이터베이스 삭제
        DROP DATABASE <name>;
    사용하고자 하는 데이터베이스를 지정
        USE <name>; 
            or 
        SELECT database(); 
    칼럼 데이터 타입의 종류
        Numberic Types
            - INT
            - SMALLINT
            - TINYINT
            - MEDIUMINT
            - BIGINT
            - DECIMAL
            - NUMERIC
            - FLOAT
            - DOUBLE
            - BIT
        String Types
            - CHAR
            - VARCHAR
            - BINARY
            - VARBINARY
            - BLOB
            - TINYBLOB
            - MEDIUMBLOB
            - LARGEBLOB
            - TEXT
            - TINYTEXT
            - MEDIUMTEXT
            - LONGTEXT
            - ENUM
        Date Tyes
            - DATE
            - DATETIME
            - TIMESTAMP
            - TIME
            - YEAR
    가장 많이 쓰이는 건 INT, VARCHAR
    데이터 타입에 대한 자세한 내용은 MySQL 공식 문서에서 확인
    테이블 생성과 동시에 칼럼 정의하기
        CREATE TABLE <name>
            (
                <column_name> <data_type>,
                <column_name> <data_type>,
            );
    현재 데이터베이스가 가진 모든 테이블들을 조회
        SHOW TABLES; 
    해당 이름의 테이블이 가진 칼럼값들을 조회
        SHOW COLUMNS FROM <table_name>;
            or
        DESC <table_name>;
    주석 
        -- 
    해당 이름의 테이블을 삭제
        DROP TABLE <table_name>; 
    
### 데이터 삽입

    특정 테이블에 특정 데이터 삽입하기
        INSERT INTO <table_name>(<column_name_1>, <column_name_2>, ...)
        VALUES (<column_value_1>, <column_value_2>, ...);
    컬럼 이름들의 순서는 상관없으나, 선언한 컬럼 이름의 순서대로 VALUES 값을 넣어줘야 한다.
    한번에 여러 데이터 삽입하기
        INSERT INTO <table_name>(<column_name_1>, <column_name_2>, ...)
        VALUES (<column_value_1>, <column_value_2>, ...)
                ,(<column_value_1>, <column_value_2>, ...)
                ,(<column_value_1>, <column_value_2>, ...)
                , ...;
    특정 테이블에서 모든 데이터 조회 
        SELECT * FROM <table_name>;
    데이터가 null 값을 허용하지 않도록 하는 수식어 NOT NULL
        ex) CREATE TABLE cats(name VARCHAR(100) NOT NULL, age INT NOT NULL);
    SQL을 쓸 때는 기본적으로 작은 따옴표를 쓰는게 좋다.
    다만 따옴표 안에 또다른 따옴표가 들어가는 케이스라면 escape(\)를 붙여야 한다.
    작은 따옴표 안에 큰따옴표가 들어가는 건 상관 없음.
    데이터를 입력하지 않았을 때 적용되는 기본값 수식어 DEFAULT
        ex) CREATE TABLE cats(name VARCHAR(100) DEFAULT 'unnamed', age INT DEFAULT 99)
    DEFAULT를 선언한다고 NULL 입력을 막아주진 않는다. 둘 다 써야 한다.
    Primary Key = 유일한 식별자
        CREATE TABLE <table_name>(
            <primary_key> <data_type>,
            <columne_name_1> <data_type>,
            <columne_name_2> <data_type>,
            ...,
            PRIMARY KEY(<primary_key>)
        );
        ex) CREATE TABLE cats (
            id INT,
            name VARCHAR(100),
            age INT
            PRIMARY KEY(id)
        );
    PRIMARY KEY는 기본적으로 NOT NULL을 포함한다.
    AUTO_INCREMENT를 붙이면 입력하지 않아도 자동으로 INT 값을 생성한다.
        ex) CREATE TABLE cats(
            id INT AUTO_INCREMENT,
            name VARCHAR(100),
            age INT,
            PRIMARY KEY(id)
        );
        
### 제약 조건 및 테이블 변경

    UNIQUE: 유일성 보장. 이미 존재하는 값이 입력되면 에러.
        ex) CREATE TABLE contacts(
            name VARCHAR(100) NOT NULL,
            phone VARCHAR(15) NOT NULL UNIQUE
        );
    CHECK: 특정 조건 보장. 조건에 맞지 않는 값이 입력되면 에러.
        ex) CREATE TABLE partiers(
            name VARCHAR(50),
            age INT CHECK (age > 18)
        );
    CONSTRAINT: 조건에 이름을 달아 해당 조건이 맞지 않는 오류가 발생할 때 해당 이름이 뜨도록 할 수 있다.
        ex) CREATE TABLE partiers (
            name VARCHAR(50),
            age INT,
            CONSTRAINT age_over_18 CHECK (age > 18)
        );
    ALTER TABLE: 테이블 정의를 바꿀 수 있다. 수많은 다른 문법과 연계되어 사용되는데 정확한 내용은 공식 문서 확인.
    ADD COLUMN: 새로운 컬럼을 추가. 기존의 데이터들은 DEFAULT 값을 주지 않으면 NULL 값으로 초기화된다.
        ex) ALTER TABLE companies
            ADD COLUMN city VARCHAR(25);
    DROP COLUMN: 칼럼 삭제 
        ex) ALTER TABLE companies
            DROP COLUMN city;
    RENAME TABLE: 테이블 이름 변경
        ex) RENAME TABLE companies TO suppliers;
                or
            ALTER TABLE companies
            RENAME TO suppliers;
    RENAME COLUMN: 컬럼 이름 변경
        ex) ALTER TABLE companies
            REANME COLUN name TO company_name;
    MODIFY: 컬럼의 데이터 타입 변경.
        ex) ALTER TABLE suppliers
            MODIFY biz_name VARCHAR(100);
    CHANGE: 컬럼의 이름도 변경하고 데이터 타입도 변경.
        ex) ALTER TABLE suppliers
            CHANGE business biz_name VARCHAR(50);
    ADD/DROP CONSTRAINT _ CHECK _: 새로운 제약조건을 걸거나 삭제할 수 있다.
        ex) ALTER TABLE houses 
            ADD CONSTRAINT 'positive_pprice'
            CHECK (purchase_price >= 0);
        ex) ALTER TABLE houses
            DROP CONSTRAINT positive_pprice;
            
### CRUD
    
    Create: INSERT INTO _ VALUES _
    Read: SELECT _ FROM _
        SELECT <column_name> FROM <table_name>;: 특정 테이블에서 특정 컬럼 값만 조회
        SELECT <column_1>, <column_2> FROM <table_name>;: 여러개도 가능
        SELECT * FROM <table_name> WHERE <condition>;: 조건을 만족하는 모든 데이터 조회
        SELECT <column_name> AS <alias> FROM <table_name>;: 컬럼 이름을 바꿔서(Alias) 조회 
    Update: UPDATE _ SET _ WHERE _
        UPDATE <table_name> SET <update> WHERE <condition>;: 특정 테이블에서 특정 조건을 만족하는 데이터를 일괄 변경
    Delete: DELETE FROM _ WHERE _
        DELETE FROM <table_name>: 조건을 걸지 않으면 테이블 데이터 전체가 지워진다.
        DELETE FROM <table_name> WHERE <condition>;: 테이블 내에서 조건에 맞는 데이터를 일괄 삭제.

### 문자열 함수
    
    수많은 문자열 함수가 존재하니 정확한 건 mysql 공식문서를 확인한다.
    CONCAT(_, _, ...): 여러 문자열을 이어준다.
        ex) SELECT CONCAT('h', 'e', 'l', 'l', 'o'); => hello
        ex) SELECT CONCAT(first_name, last_name) FROM contacts;
    CONCAT_WS(<separator>, _, _, ...);: 문자열을 붙이되, 첫번째 인자로 주어진 separator를 사용한다.
        ex) SELECT CONCAT_WS('-', '000', '1111', '2222'); => 000-1111-2222
    SUBSTRING(<string>, <start_index>, <char_count>);: 문자열의 일부 반환
        ex) SELECT SUBSTRING('Hello World', 1, 4); => Hell
        ex) SELECT SUBSTRING('Hello World', -4, 4); => orld
    SUBSTRING(<string>, <start_index>);: start_index부터 끝까지 반환
        ex) SELECT SUBSTRING('Hello World', 7); => World
        ex) SELECT SUBSTRING('Hello World', -3); => rld
    SUBSTRING 대신 SUBSTR을 써도 무방하다.
    REPLACE(<string>, <from>, <to>);: string 안에서 모든 from을 to로 바꾼다. Case-sensitive.
        ex) SELECT REPLACE('Hello World', 'Hell', 'Heaven'); => Heaveno World
    REVERSE(<string>);: string을 뒤집어서 반환한다.
        ex) SELECT REVERSE('chicken'); => nekcihc
    CHAR_LENGTH(<string>);: string의 길이를 반환한다.
        ex) CHAR_LENGTH('Hey!') => 4    
    UPPER(<string>)/LOWER(<string>);: 대문자화/소문자화.
    UPPER = UCASE
    LOWER = LCASE
    INSERT(<string>, <position>, <length>, <new_string>);
    LEFT(<string>, <length>);
    RIGHT(<string>, <length>);
    REPEAT(<string>, <count>);
    TRIM(<string>);
    TRIM(LEADING <string_to_trim> FROM <string>);
    
### 선택사항 정교화

    DISTINCT <column_name>;: 테이블 내에서 동일한 column 값을 가지지 않는 것만 반환.
        ex) SELECT DISTINC author_lnmae FROM books;
    ORDER BY <column_name> ASC|DESC;: 출력을 특정 column을 기준으로 오름/내림차순으로 정렬.
        ex) SELECT author_lname FROM books ORDER BY author_lname; (생략하면 ASC)
        ex) SELECT author_lname FROM books ORDER BY 2; (숫자를 쓰면 n번째 칼럼으로 인식한다)
        ex) SELECT author_lname FROM books ORDER BY author_lname, author_fname; (여러 칼럼을 쓸 수 있다)
        ex) SELECT CONCAT(author_fname, ' ', author_lname) AS author FROM books ORDER BY author (원래 칼럼에 없던 Alias를 기준으로 쓸 수도 있다)
    LIMIT <number>;: 출력되는 데이터의 갯수를 제한한다.
        ex) SELECT book_id FROM books LIMIT 5;
        ex) SELEcT book_id FROM books LIMIT 3, 5; (숫자 두개를 쓰면 n부터 m개의 데이터를 출력한다)
        숫자가 전체 데이터 수를 넘어도 상관없다.
    LIKE <string_pattern>;: 특정 패턴을 만족하는 문자열을 걸러낼 수 있다.
        ex) SELECT * FROM books WHERE author_fname LIKE '%da%' (%는 와일드카드라고 하며, 무엇이든 올 수 있다는 의미를 가진다)
        ex) SELECT * FROM books WHERE author_fname LIKE '____' (_는 한글자를 뜻하며, 4개면 4글자의 무언가를 뜻한다)
        ex) SELECT * FROM books WHERE author_fname LIKE '%\%%' (와일드카드가 아닌 %를 표현하려면 이스케이프(\)를 쓰면 된다)
        
### 데이터 타입

    

## 진행상황

## 피드백 

## 참고자료
